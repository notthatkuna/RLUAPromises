local promise = {}
local all = {}

function promise.new()
	local newpromise = {}
	newpromise.db = false
	newpromise.state = {'unresolved', ''}
	newpromise.identification = game:GetService("HttpService"):GenerateGUID(true);
	newpromise._function = nil
	local _resolved = game:GetService("ServerScriptService").promiseFolder.resolved
	local _rejected = game:GetService("ServerScriptService").promiseFolder.rejected
	newpromise.resolved = game:GetService("ServerScriptService").promiseFolder.resolved.Event
	newpromise.rejected = game:GetService("ServerScriptService").promiseFolder.rejected.Event
	local idCopy = newpromise.identification
	
	local function nError(message)
		error("\nError generated by <Promise>#"..newpromise.identification.."\n"..message)
	end
	
	spawn(function()
		while wait() do
			if newpromise.identification ~= idCopy then
				newpromise.identification = idCopy
				print("<Promise>#"..idCopy.."'s identification was changed; rolled back to latest copy")
			end
		end
	end)
	function newpromise.resolve(reason)
		if newpromise.db then return end
		newpromise.db = true
		spawn(function()
			wait()
			newpromise.db = false
		end)
		if newpromise.state[1] ~= 'unresolved' then nError("Cannot resolve/reject a promise without state \"unresolved\"") end
		
		newpromise.state = {'resolved', reason or "Undefined reason"}
		_resolved:Fire(newpromise.identification,newpromise.state)
	end
	function newpromise.reject(reason)
		if newpromise.db then return end
		newpromise.db = true
		spawn(function()
			wait()
			newpromise.db = false
		end)
		if newpromise.state[1] ~= 'unresolved' then nError("Cannot resolve/reject a promise without state \"unresolved\"") end
		
		newpromise.state = {'rejected', reason or "Undefined reason"}
		_rejected:Fire(newpromise.identification,newpromise.state)
	end
	function newpromise.getstate()
		return newpromise.state
	end
	function newpromise.setFunction(f)
		newpromise._function = f
	end
	function newpromise.execute()
		if typeof(newpromise._function) ~= "function" then nError("<Promise>._function was *nil* or was not a function; use <Promise>.setFunction(type function)") end
		spawn(function()
			newpromise._function()
		end)
	end
	function newpromise.isUnresolved()
		if newpromise.getstate()[1] == 'unresolved' then return true else return false end
	end
	table.insert(all,newpromise)
	return newpromise
end

function promise.resolveAll(reason:string,usepcall:boolean)
	local dumpLog = {}
	if typeof(reason) ~= "string" then error("reason in function PromiseModule.resolveAll* was not a string") end
	if typeof(usepcall) ~= "boolean" then error("usepcall in function PromiseModule.resolveAll* was not a boolean value") end
	if usepcall then
		for _,currentPromise in pairs(all) do
			local s,e = pcall(function()
				currentPromise.resolve(reason)
			end)
			if e then table.insert(dumpLog,e) end
		end
		return dumpLog
	else
		for _,currentPromise in pairs(all) do
			currentPromise.resolve(reason)
		end
	end	
end

return promise
